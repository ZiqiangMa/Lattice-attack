\section{Conclusion}
\label{sec:conclusion}
In this paper, we demonstrate a practical attack on the ECDSA algorithm implemented  with the scalar multiplication using the wNAF representation, which is adopted in OpenSSL versions between 0.9.7 and 1.1.0h.
We improve the cache side channel attack
 by using the Flush+Flush technique and adding an extra monitor to the invert function.
Through them, we get the extra information, i.e., the signs of all non-zero digits of the ephemeral key.
Then, we construct the HNP and EHNP instances respectively,  to utilize the extracted information for the ECDSA private key recovery.

%Then we get the consecutive bits of the ephemeral key at each position of the non-zero digits through the Double-Add-Invert chain obtained by the cache side channel attack and
%construct a lattice attack using the HNP problem to recover the ECDSA private key.
%Finally, we propose a novel method different from \cite{Fan2016} to construct an EHNP instance to recover the ECDSA private
%key by converting it to the SVP problem and solving it with lattice reduction algorithms.
%From the side channel, we obtain $153.2$ bits of information per signature for the 256-bit ECDSA secp256k1 curve.

This is the first work to obtain the information about the signs of the non-zero digits of the ephemeral key without using performance degradation and make use of it to recover the ECDSA private key.
We applied the Flush+Flush attack to the secp256k1 curve in OpenSSL 1.1.0h to verify the availability of monitoring the invert function.
from the Double-Add-Invert chain we extract on average 154.2 bits of information per signature for the 256-bit elliptic curve.
If the obtained Double-Add-Invert chain is perfect,
2 signatures are enough to recover the ECDSA private by using the EHNP problem with a success probability no less than $24.3\%$.
This result attains the optimal bound and is the best one as ever known.



%In the future,
%we will optimize this work to use fewer signatures and achieve higher success probability by finding ways to decrease the length of consecutive bits required and using more efficient lattice reduction algorithms such as the BKZ2.0.
%Next, we will try to find a more efficient lattice construction to recover the private key,
%    making full use of the information achieved (e.g., an EHNP-based solution).
%Also, we will extend this attack to other cryptographic engines,
%    and also the blinded ephemeral keys of ECDSA.



