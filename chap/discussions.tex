\section{Discussion}
\label{sec:discussion}

\subsection{Scalar Multiplication in Other Cryptographic Libraries}
Besides the OpenSSL library, there are many cryptographic libraries that implement the scalar multiplication.
But not all of them use the wNAF representation.
We introduce some implementations of the scalar multiplication in some popular cryptographic libraries.

The mbed TLS \cite{polarssl} is an open source SSL library licensed by ARM Limited.
It does not use the wNAF algorithm to represent the scalar.
It uses a comb method that generates a sequence of bit-strings to represent the scalar $k$ so that every bit-string represents an odd number based on modifying the method in \cite{Hedabou2004ACM}.
When computing the scalar multiplication, it traverses the sequence and directly indexes the value in the precomputed points to perform the addition.
It does not use the invert function,
and this representation is hard to attack by the cache side channels because all the elements of the sequence are not zero.

Libgcrypt \cite{libgcrypt} is a cryptography library developed as a separated module of GnuPG.
It directly uses the binary representation of the scalar instead of the wNAF representation to compute the scalar multiplication in the prime field.
%Although it does not exploit the wNAF algorithm, it is vulnerable to the cache side channel attacks.
To resist the side channel attacks, it performs an extra addition operation when the binary bit of the scalar is zero so that in every bit the double and addition are both performed.
Therefore, lattice attacks to this library are invalid.

%Crypto++ Library \cite{cryptopp} is a free C++ class library of cryptographic algorithms and schemes.

%\subsection{The Method of Constructing Lattice Attacks}
%In our work, we construct an HNP instance using partial information about the $k$ obtained from the cache side channel attack.
% From the Inequation~\ref{lattice2}, the length of the most significant bits of $\lfloor\alpha t_i\rfloor$ is $l/2-\log_{2}{3} -1$.
%When constructing the lattice, it should contain the information about the most significant bits of $\lfloor\alpha t_i\rfloor$.
%Thus it requests $l/2-\log_{2}{3} -1 \geq 1$, so $l$ representing the minimal length of the consecutive bits needs to be larger than $7$.
%In practice, only when $l > 8$, we successfully recover the ECDSA private key in our experiments.
%However, the average length of the consecutive bits is $3$, which is much smaller than needed.
%This makes it impossible to use all the bits obtained through the cache side channel attack  to construct the lattice attack.
%Although in theory we only need $2$ signatures to recover the 256-bit private key,
% in practice we need at least $60$ signatures to get enough information satisfied the restriction on $l$ to construct the lattice attack.
%Therefore due to the restriction on $l$, we can not make full use of the information obtained from the cache side channel although we obtained $153.2$ bits information per signature on average.
%
%However, based on the work in~\cite{Nguyen2002} and \cite{Liu2013},
% in theory when the length of the consecutive bits is $2$, this sequence of  the consecutive bits can be used to construct the lattice attack.
%In our work, all the sequences of consecutive bits (except the least) obtained from the cache side channel satisfy $l \geq 2$,
% and the length the consecutive least significant bits is larger than $1$.
% That means at least $152.2$ bits information we obtained is valid and exploitable, only $1$ bit information may be discarded.
%Therefore, if we find an efficient way to construct the lattice attack, making full use of all the information of the consecutive bits,
%   the number of signatures required to recover the private key can be greatly reduced, even the best case only $2$ signatures is enough for a 256-bit private key.
%In theory, this result is better than the prior work in \cite{Fan2016} which theoretically needs 3 signatures for a 256-bit private key.
%This is what we are going to do next, finding a suitable and powerful method to construct the lattice attack.

%我们的工作中，我们使用了XX方法
%我们的方法有什么限制：l需要很大
%造成什么结果：无法利用所有的有效数据，需要使用很多的签名
%所以尽管我们获取到了许多数据，但并不能够充分利用。

%而理论上讲，我们获取到的数据满足l>=3的条件，
%根据参考文献，只要l=2就可以被用来进行格攻击
%因此，我们获取到的数据全部都是有效数据，可以被利用的，并不存在需要抛弃的数据
%只需要找到合适的方法来构造格攻击，就可以充分利用数据，从而大大降低所需要的签名数量，
%理论上，我们只需要两个签名，结果会好于fan。
%这也是我们接下来要去做的工作，找到一个合适的构造格的方法。


\subsection{The Precision Of The Cache Side Channel Attacks}












